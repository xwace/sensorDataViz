// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensor_data.proto

#ifndef PROTOBUF_sensor_5fdata_2eproto__INCLUDED
#define PROTOBUF_sensor_5fdata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_sensor_5fdata_2eproto();
void protobuf_InitDefaults_sensor_5fdata_2eproto();
void protobuf_AssignDesc_sensor_5fdata_2eproto();
void protobuf_ShutdownFile_sensor_5fdata_2eproto();

class Imu;
class Imu_AngularVelocity;
class Imu_LinearAcceleration;
class Imu_Orientation;
class LaserScan;
class Odometry;
class Odometry_Pose;
class Odometry_Pose_Orientation;
class Odometry_Pose_Position;
class Odometry_Twist;
class Odometry_Twist_Angular;
class Odometry_Twist_Linear;
class PointCloud;
class SensorData;
class YXPoint3D;

// ===================================================================

class LaserScan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LaserScan) */ {
 public:
  LaserScan();
  virtual ~LaserScan();

  LaserScan(const LaserScan& from);

  inline LaserScan& operator=(const LaserScan& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaserScan& default_instance();

  static const LaserScan* internal_default_instance();

  void Swap(LaserScan* other);

  // implements Message ----------------------------------------------

  inline LaserScan* New() const { return New(NULL); }

  LaserScan* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LaserScan& from);
  void MergeFrom(const LaserScan& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LaserScan* other);
  void UnsafeMergeFrom(const LaserScan& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 angle_min = 1;
  void clear_angle_min();
  static const int kAngleMinFieldNumber = 1;
  ::google::protobuf::int32 angle_min() const;
  void set_angle_min(::google::protobuf::int32 value);

  // optional int32 angle_max = 2;
  void clear_angle_max();
  static const int kAngleMaxFieldNumber = 2;
  ::google::protobuf::int32 angle_max() const;
  void set_angle_max(::google::protobuf::int32 value);

  // optional int32 angle_increment = 3;
  void clear_angle_increment();
  static const int kAngleIncrementFieldNumber = 3;
  ::google::protobuf::int32 angle_increment() const;
  void set_angle_increment(::google::protobuf::int32 value);

  // optional int32 time_increment = 4;
  void clear_time_increment();
  static const int kTimeIncrementFieldNumber = 4;
  ::google::protobuf::int32 time_increment() const;
  void set_time_increment(::google::protobuf::int32 value);

  // optional int32 scan_time = 5;
  void clear_scan_time();
  static const int kScanTimeFieldNumber = 5;
  ::google::protobuf::int32 scan_time() const;
  void set_scan_time(::google::protobuf::int32 value);

  // optional int32 range_min = 6;
  void clear_range_min();
  static const int kRangeMinFieldNumber = 6;
  ::google::protobuf::int32 range_min() const;
  void set_range_min(::google::protobuf::int32 value);

  // optional int32 range_max = 7;
  void clear_range_max();
  static const int kRangeMaxFieldNumber = 7;
  ::google::protobuf::int32 range_max() const;
  void set_range_max(::google::protobuf::int32 value);

  // repeated int32 ranges = 8;
  int ranges_size() const;
  void clear_ranges();
  static const int kRangesFieldNumber = 8;
  ::google::protobuf::int32 ranges(int index) const;
  void set_ranges(int index, ::google::protobuf::int32 value);
  void add_ranges(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ranges() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ranges();

  // repeated int32 intensities = 9;
  int intensities_size() const;
  void clear_intensities();
  static const int kIntensitiesFieldNumber = 9;
  ::google::protobuf::int32 intensities(int index) const;
  void set_intensities(int index, ::google::protobuf::int32 value);
  void add_intensities(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      intensities() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_intensities();

  // @@protoc_insertion_point(class_scope:LaserScan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ranges_;
  mutable int _ranges_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > intensities_;
  mutable int _intensities_cached_byte_size_;
  ::google::protobuf::int32 angle_min_;
  ::google::protobuf::int32 angle_max_;
  ::google::protobuf::int32 angle_increment_;
  ::google::protobuf::int32 time_increment_;
  ::google::protobuf::int32 scan_time_;
  ::google::protobuf::int32 range_min_;
  ::google::protobuf::int32 range_max_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_sensor_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_sensor_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_sensor_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensor_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<LaserScan> LaserScan_default_instance_;

// -------------------------------------------------------------------

class YXPoint3D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:YXPoint3D) */ {
 public:
  YXPoint3D();
  virtual ~YXPoint3D();

  YXPoint3D(const YXPoint3D& from);

  inline YXPoint3D& operator=(const YXPoint3D& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YXPoint3D& default_instance();

  static const YXPoint3D* internal_default_instance();

  void Swap(YXPoint3D* other);

  // implements Message ----------------------------------------------

  inline YXPoint3D* New() const { return New(NULL); }

  YXPoint3D* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const YXPoint3D& from);
  void MergeFrom(const YXPoint3D& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YXPoint3D* other);
  void UnsafeMergeFrom(const YXPoint3D& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // optional int32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // optional int32 z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::int32 z() const;
  void set_z(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:YXPoint3D)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_sensor_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_sensor_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_sensor_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensor_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<YXPoint3D> YXPoint3D_default_instance_;

// -------------------------------------------------------------------

class PointCloud : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PointCloud) */ {
 public:
  PointCloud();
  virtual ~PointCloud();

  PointCloud(const PointCloud& from);

  inline PointCloud& operator=(const PointCloud& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointCloud& default_instance();

  static const PointCloud* internal_default_instance();

  void Swap(PointCloud* other);

  // implements Message ----------------------------------------------

  inline PointCloud* New() const { return New(NULL); }

  PointCloud* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointCloud& from);
  void MergeFrom(const PointCloud& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PointCloud* other);
  void UnsafeMergeFrom(const PointCloud& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .YXPoint3D points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  const ::YXPoint3D& points(int index) const;
  ::YXPoint3D* mutable_points(int index);
  ::YXPoint3D* add_points();
  ::google::protobuf::RepeatedPtrField< ::YXPoint3D >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::YXPoint3D >&
      points() const;

  // @@protoc_insertion_point(class_scope:PointCloud)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::YXPoint3D > points_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_sensor_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_sensor_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_sensor_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensor_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<PointCloud> PointCloud_default_instance_;

// -------------------------------------------------------------------

class Odometry_Pose_Position : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Odometry.Pose.Position) */ {
 public:
  Odometry_Pose_Position();
  virtual ~Odometry_Pose_Position();

  Odometry_Pose_Position(const Odometry_Pose_Position& from);

  inline Odometry_Pose_Position& operator=(const Odometry_Pose_Position& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Odometry_Pose_Position& default_instance();

  static const Odometry_Pose_Position* internal_default_instance();

  void Swap(Odometry_Pose_Position* other);

  // implements Message ----------------------------------------------

  inline Odometry_Pose_Position* New() const { return New(NULL); }

  Odometry_Pose_Position* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Odometry_Pose_Position& from);
  void MergeFrom(const Odometry_Pose_Position& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Odometry_Pose_Position* other);
  void UnsafeMergeFrom(const Odometry_Pose_Position& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // optional int32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // optional int32 z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::int32 z() const;
  void set_z(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Odometry.Pose.Position)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_sensor_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_sensor_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_sensor_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensor_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Odometry_Pose_Position> Odometry_Pose_Position_default_instance_;

// -------------------------------------------------------------------

class Odometry_Pose_Orientation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Odometry.Pose.Orientation) */ {
 public:
  Odometry_Pose_Orientation();
  virtual ~Odometry_Pose_Orientation();

  Odometry_Pose_Orientation(const Odometry_Pose_Orientation& from);

  inline Odometry_Pose_Orientation& operator=(const Odometry_Pose_Orientation& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Odometry_Pose_Orientation& default_instance();

  static const Odometry_Pose_Orientation* internal_default_instance();

  void Swap(Odometry_Pose_Orientation* other);

  // implements Message ----------------------------------------------

  inline Odometry_Pose_Orientation* New() const { return New(NULL); }

  Odometry_Pose_Orientation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Odometry_Pose_Orientation& from);
  void MergeFrom(const Odometry_Pose_Orientation& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Odometry_Pose_Orientation* other);
  void UnsafeMergeFrom(const Odometry_Pose_Orientation& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // optional int32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // optional int32 z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::int32 z() const;
  void set_z(::google::protobuf::int32 value);

  // optional int32 w = 4;
  void clear_w();
  static const int kWFieldNumber = 4;
  ::google::protobuf::int32 w() const;
  void set_w(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Odometry.Pose.Orientation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  ::google::protobuf::int32 w_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_sensor_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_sensor_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_sensor_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensor_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Odometry_Pose_Orientation> Odometry_Pose_Orientation_default_instance_;

// -------------------------------------------------------------------

class Odometry_Pose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Odometry.Pose) */ {
 public:
  Odometry_Pose();
  virtual ~Odometry_Pose();

  Odometry_Pose(const Odometry_Pose& from);

  inline Odometry_Pose& operator=(const Odometry_Pose& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Odometry_Pose& default_instance();

  static const Odometry_Pose* internal_default_instance();

  void Swap(Odometry_Pose* other);

  // implements Message ----------------------------------------------

  inline Odometry_Pose* New() const { return New(NULL); }

  Odometry_Pose* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Odometry_Pose& from);
  void MergeFrom(const Odometry_Pose& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Odometry_Pose* other);
  void UnsafeMergeFrom(const Odometry_Pose& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Odometry_Pose_Position Position;
  typedef Odometry_Pose_Orientation Orientation;

  // accessors -------------------------------------------------------

  // optional .Odometry.Pose.Position position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::Odometry_Pose_Position& position() const;
  ::Odometry_Pose_Position* mutable_position();
  ::Odometry_Pose_Position* release_position();
  void set_allocated_position(::Odometry_Pose_Position* position);

  // optional .Odometry.Pose.Orientation orientation = 2;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 2;
  const ::Odometry_Pose_Orientation& orientation() const;
  ::Odometry_Pose_Orientation* mutable_orientation();
  ::Odometry_Pose_Orientation* release_orientation();
  void set_allocated_orientation(::Odometry_Pose_Orientation* orientation);

  // @@protoc_insertion_point(class_scope:Odometry.Pose)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Odometry_Pose_Position* position_;
  ::Odometry_Pose_Orientation* orientation_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_sensor_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_sensor_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_sensor_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensor_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Odometry_Pose> Odometry_Pose_default_instance_;

// -------------------------------------------------------------------

class Odometry_Twist_Linear : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Odometry.Twist.Linear) */ {
 public:
  Odometry_Twist_Linear();
  virtual ~Odometry_Twist_Linear();

  Odometry_Twist_Linear(const Odometry_Twist_Linear& from);

  inline Odometry_Twist_Linear& operator=(const Odometry_Twist_Linear& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Odometry_Twist_Linear& default_instance();

  static const Odometry_Twist_Linear* internal_default_instance();

  void Swap(Odometry_Twist_Linear* other);

  // implements Message ----------------------------------------------

  inline Odometry_Twist_Linear* New() const { return New(NULL); }

  Odometry_Twist_Linear* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Odometry_Twist_Linear& from);
  void MergeFrom(const Odometry_Twist_Linear& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Odometry_Twist_Linear* other);
  void UnsafeMergeFrom(const Odometry_Twist_Linear& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // optional int32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // optional int32 z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::int32 z() const;
  void set_z(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Odometry.Twist.Linear)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_sensor_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_sensor_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_sensor_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensor_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Odometry_Twist_Linear> Odometry_Twist_Linear_default_instance_;

// -------------------------------------------------------------------

class Odometry_Twist_Angular : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Odometry.Twist.Angular) */ {
 public:
  Odometry_Twist_Angular();
  virtual ~Odometry_Twist_Angular();

  Odometry_Twist_Angular(const Odometry_Twist_Angular& from);

  inline Odometry_Twist_Angular& operator=(const Odometry_Twist_Angular& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Odometry_Twist_Angular& default_instance();

  static const Odometry_Twist_Angular* internal_default_instance();

  void Swap(Odometry_Twist_Angular* other);

  // implements Message ----------------------------------------------

  inline Odometry_Twist_Angular* New() const { return New(NULL); }

  Odometry_Twist_Angular* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Odometry_Twist_Angular& from);
  void MergeFrom(const Odometry_Twist_Angular& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Odometry_Twist_Angular* other);
  void UnsafeMergeFrom(const Odometry_Twist_Angular& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // optional int32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // optional int32 z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::int32 z() const;
  void set_z(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Odometry.Twist.Angular)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_sensor_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_sensor_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_sensor_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensor_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Odometry_Twist_Angular> Odometry_Twist_Angular_default_instance_;

// -------------------------------------------------------------------

class Odometry_Twist : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Odometry.Twist) */ {
 public:
  Odometry_Twist();
  virtual ~Odometry_Twist();

  Odometry_Twist(const Odometry_Twist& from);

  inline Odometry_Twist& operator=(const Odometry_Twist& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Odometry_Twist& default_instance();

  static const Odometry_Twist* internal_default_instance();

  void Swap(Odometry_Twist* other);

  // implements Message ----------------------------------------------

  inline Odometry_Twist* New() const { return New(NULL); }

  Odometry_Twist* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Odometry_Twist& from);
  void MergeFrom(const Odometry_Twist& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Odometry_Twist* other);
  void UnsafeMergeFrom(const Odometry_Twist& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Odometry_Twist_Linear Linear;
  typedef Odometry_Twist_Angular Angular;

  // accessors -------------------------------------------------------

  // optional .Odometry.Twist.Linear linear = 1;
  bool has_linear() const;
  void clear_linear();
  static const int kLinearFieldNumber = 1;
  const ::Odometry_Twist_Linear& linear() const;
  ::Odometry_Twist_Linear* mutable_linear();
  ::Odometry_Twist_Linear* release_linear();
  void set_allocated_linear(::Odometry_Twist_Linear* linear);

  // optional .Odometry.Twist.Angular angular = 2;
  bool has_angular() const;
  void clear_angular();
  static const int kAngularFieldNumber = 2;
  const ::Odometry_Twist_Angular& angular() const;
  ::Odometry_Twist_Angular* mutable_angular();
  ::Odometry_Twist_Angular* release_angular();
  void set_allocated_angular(::Odometry_Twist_Angular* angular);

  // @@protoc_insertion_point(class_scope:Odometry.Twist)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Odometry_Twist_Linear* linear_;
  ::Odometry_Twist_Angular* angular_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_sensor_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_sensor_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_sensor_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensor_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Odometry_Twist> Odometry_Twist_default_instance_;

// -------------------------------------------------------------------

class Odometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Odometry) */ {
 public:
  Odometry();
  virtual ~Odometry();

  Odometry(const Odometry& from);

  inline Odometry& operator=(const Odometry& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Odometry& default_instance();

  static const Odometry* internal_default_instance();

  void Swap(Odometry* other);

  // implements Message ----------------------------------------------

  inline Odometry* New() const { return New(NULL); }

  Odometry* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Odometry& from);
  void MergeFrom(const Odometry& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Odometry* other);
  void UnsafeMergeFrom(const Odometry& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Odometry_Pose Pose;
  typedef Odometry_Twist Twist;

  // accessors -------------------------------------------------------

  // optional .Odometry.Pose pose = 1;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 1;
  const ::Odometry_Pose& pose() const;
  ::Odometry_Pose* mutable_pose();
  ::Odometry_Pose* release_pose();
  void set_allocated_pose(::Odometry_Pose* pose);

  // optional .Odometry.Twist twist = 2;
  bool has_twist() const;
  void clear_twist();
  static const int kTwistFieldNumber = 2;
  const ::Odometry_Twist& twist() const;
  ::Odometry_Twist* mutable_twist();
  ::Odometry_Twist* release_twist();
  void set_allocated_twist(::Odometry_Twist* twist);

  // optional int64 header_timestamp = 3;
  void clear_header_timestamp();
  static const int kHeaderTimestampFieldNumber = 3;
  ::google::protobuf::int64 header_timestamp() const;
  void set_header_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Odometry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Odometry_Pose* pose_;
  ::Odometry_Twist* twist_;
  ::google::protobuf::int64 header_timestamp_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_sensor_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_sensor_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_sensor_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensor_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Odometry> Odometry_default_instance_;

// -------------------------------------------------------------------

class Imu_LinearAcceleration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Imu.LinearAcceleration) */ {
 public:
  Imu_LinearAcceleration();
  virtual ~Imu_LinearAcceleration();

  Imu_LinearAcceleration(const Imu_LinearAcceleration& from);

  inline Imu_LinearAcceleration& operator=(const Imu_LinearAcceleration& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Imu_LinearAcceleration& default_instance();

  static const Imu_LinearAcceleration* internal_default_instance();

  void Swap(Imu_LinearAcceleration* other);

  // implements Message ----------------------------------------------

  inline Imu_LinearAcceleration* New() const { return New(NULL); }

  Imu_LinearAcceleration* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Imu_LinearAcceleration& from);
  void MergeFrom(const Imu_LinearAcceleration& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Imu_LinearAcceleration* other);
  void UnsafeMergeFrom(const Imu_LinearAcceleration& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // optional int32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // optional int32 z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::int32 z() const;
  void set_z(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Imu.LinearAcceleration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_sensor_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_sensor_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_sensor_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensor_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Imu_LinearAcceleration> Imu_LinearAcceleration_default_instance_;

// -------------------------------------------------------------------

class Imu_AngularVelocity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Imu.AngularVelocity) */ {
 public:
  Imu_AngularVelocity();
  virtual ~Imu_AngularVelocity();

  Imu_AngularVelocity(const Imu_AngularVelocity& from);

  inline Imu_AngularVelocity& operator=(const Imu_AngularVelocity& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Imu_AngularVelocity& default_instance();

  static const Imu_AngularVelocity* internal_default_instance();

  void Swap(Imu_AngularVelocity* other);

  // implements Message ----------------------------------------------

  inline Imu_AngularVelocity* New() const { return New(NULL); }

  Imu_AngularVelocity* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Imu_AngularVelocity& from);
  void MergeFrom(const Imu_AngularVelocity& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Imu_AngularVelocity* other);
  void UnsafeMergeFrom(const Imu_AngularVelocity& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // optional int32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // optional int32 z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::int32 z() const;
  void set_z(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Imu.AngularVelocity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_sensor_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_sensor_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_sensor_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensor_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Imu_AngularVelocity> Imu_AngularVelocity_default_instance_;

// -------------------------------------------------------------------

class Imu_Orientation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Imu.Orientation) */ {
 public:
  Imu_Orientation();
  virtual ~Imu_Orientation();

  Imu_Orientation(const Imu_Orientation& from);

  inline Imu_Orientation& operator=(const Imu_Orientation& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Imu_Orientation& default_instance();

  static const Imu_Orientation* internal_default_instance();

  void Swap(Imu_Orientation* other);

  // implements Message ----------------------------------------------

  inline Imu_Orientation* New() const { return New(NULL); }

  Imu_Orientation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Imu_Orientation& from);
  void MergeFrom(const Imu_Orientation& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Imu_Orientation* other);
  void UnsafeMergeFrom(const Imu_Orientation& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // optional int32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // optional int32 z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::int32 z() const;
  void set_z(::google::protobuf::int32 value);

  // optional int32 w = 4;
  void clear_w();
  static const int kWFieldNumber = 4;
  ::google::protobuf::int32 w() const;
  void set_w(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Imu.Orientation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  ::google::protobuf::int32 w_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_sensor_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_sensor_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_sensor_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensor_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Imu_Orientation> Imu_Orientation_default_instance_;

// -------------------------------------------------------------------

class Imu : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Imu) */ {
 public:
  Imu();
  virtual ~Imu();

  Imu(const Imu& from);

  inline Imu& operator=(const Imu& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Imu& default_instance();

  static const Imu* internal_default_instance();

  void Swap(Imu* other);

  // implements Message ----------------------------------------------

  inline Imu* New() const { return New(NULL); }

  Imu* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Imu& from);
  void MergeFrom(const Imu& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Imu* other);
  void UnsafeMergeFrom(const Imu& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Imu_LinearAcceleration LinearAcceleration;
  typedef Imu_AngularVelocity AngularVelocity;
  typedef Imu_Orientation Orientation;

  // accessors -------------------------------------------------------

  // optional .Imu.LinearAcceleration linear_acceleration = 1;
  bool has_linear_acceleration() const;
  void clear_linear_acceleration();
  static const int kLinearAccelerationFieldNumber = 1;
  const ::Imu_LinearAcceleration& linear_acceleration() const;
  ::Imu_LinearAcceleration* mutable_linear_acceleration();
  ::Imu_LinearAcceleration* release_linear_acceleration();
  void set_allocated_linear_acceleration(::Imu_LinearAcceleration* linear_acceleration);

  // optional .Imu.AngularVelocity angular_velocity = 2;
  bool has_angular_velocity() const;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 2;
  const ::Imu_AngularVelocity& angular_velocity() const;
  ::Imu_AngularVelocity* mutable_angular_velocity();
  ::Imu_AngularVelocity* release_angular_velocity();
  void set_allocated_angular_velocity(::Imu_AngularVelocity* angular_velocity);

  // optional .Imu.Orientation orientation = 3;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 3;
  const ::Imu_Orientation& orientation() const;
  ::Imu_Orientation* mutable_orientation();
  ::Imu_Orientation* release_orientation();
  void set_allocated_orientation(::Imu_Orientation* orientation);

  // optional int64 header_timestamp = 4;
  void clear_header_timestamp();
  static const int kHeaderTimestampFieldNumber = 4;
  ::google::protobuf::int64 header_timestamp() const;
  void set_header_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Imu)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Imu_LinearAcceleration* linear_acceleration_;
  ::Imu_AngularVelocity* angular_velocity_;
  ::Imu_Orientation* orientation_;
  ::google::protobuf::int64 header_timestamp_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_sensor_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_sensor_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_sensor_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensor_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Imu> Imu_default_instance_;

// -------------------------------------------------------------------

class SensorData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SensorData) */ {
 public:
  SensorData();
  virtual ~SensorData();

  SensorData(const SensorData& from);

  inline SensorData& operator=(const SensorData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorData& default_instance();

  static const SensorData* internal_default_instance();

  void Swap(SensorData* other);

  // implements Message ----------------------------------------------

  inline SensorData* New() const { return New(NULL); }

  SensorData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorData& from);
  void MergeFrom(const SensorData& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SensorData* other);
  void UnsafeMergeFrom(const SensorData& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .PointCloud raw_laser_scan = 1;
  bool has_raw_laser_scan() const;
  void clear_raw_laser_scan();
  static const int kRawLaserScanFieldNumber = 1;
  const ::PointCloud& raw_laser_scan() const;
  ::PointCloud* mutable_raw_laser_scan();
  ::PointCloud* release_raw_laser_scan();
  void set_allocated_raw_laser_scan(::PointCloud* raw_laser_scan);

  // optional .PointCloud laser_scan_360 = 2;
  bool has_laser_scan_360() const;
  void clear_laser_scan_360();
  static const int kLaserScan360FieldNumber = 2;
  const ::PointCloud& laser_scan_360() const;
  ::PointCloud* mutable_laser_scan_360();
  ::PointCloud* release_laser_scan_360();
  void set_allocated_laser_scan_360(::PointCloud* laser_scan_360);

  // optional .PointCloud raw_point_cloud = 3;
  bool has_raw_point_cloud() const;
  void clear_raw_point_cloud();
  static const int kRawPointCloudFieldNumber = 3;
  const ::PointCloud& raw_point_cloud() const;
  ::PointCloud* mutable_raw_point_cloud();
  ::PointCloud* release_raw_point_cloud();
  void set_allocated_raw_point_cloud(::PointCloud* raw_point_cloud);

  // optional .PointCloud obs_point_cloud = 4;
  bool has_obs_point_cloud() const;
  void clear_obs_point_cloud();
  static const int kObsPointCloudFieldNumber = 4;
  const ::PointCloud& obs_point_cloud() const;
  ::PointCloud* mutable_obs_point_cloud();
  ::PointCloud* release_obs_point_cloud();
  void set_allocated_obs_point_cloud(::PointCloud* obs_point_cloud);

  // optional .Odometry odometry = 5;
  bool has_odometry() const;
  void clear_odometry();
  static const int kOdometryFieldNumber = 5;
  const ::Odometry& odometry() const;
  ::Odometry* mutable_odometry();
  ::Odometry* release_odometry();
  void set_allocated_odometry(::Odometry* odometry);

  // optional int64 secs = 6;
  void clear_secs();
  static const int kSecsFieldNumber = 6;
  ::google::protobuf::int64 secs() const;
  void set_secs(::google::protobuf::int64 value);

  // optional int64 nsecs = 7;
  void clear_nsecs();
  static const int kNsecsFieldNumber = 7;
  ::google::protobuf::int64 nsecs() const;
  void set_nsecs(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SensorData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::PointCloud* raw_laser_scan_;
  ::PointCloud* laser_scan_360_;
  ::PointCloud* raw_point_cloud_;
  ::PointCloud* obs_point_cloud_;
  ::Odometry* odometry_;
  ::google::protobuf::int64 secs_;
  ::google::protobuf::int64 nsecs_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_sensor_5fdata_2eproto_impl();
  friend void  protobuf_AddDesc_sensor_5fdata_2eproto_impl();
  friend void protobuf_AssignDesc_sensor_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensor_5fdata_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<SensorData> SensorData_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// LaserScan

// optional int32 angle_min = 1;
inline void LaserScan::clear_angle_min() {
  angle_min_ = 0;
}
inline ::google::protobuf::int32 LaserScan::angle_min() const {
  // @@protoc_insertion_point(field_get:LaserScan.angle_min)
  return angle_min_;
}
inline void LaserScan::set_angle_min(::google::protobuf::int32 value) {
  
  angle_min_ = value;
  // @@protoc_insertion_point(field_set:LaserScan.angle_min)
}

// optional int32 angle_max = 2;
inline void LaserScan::clear_angle_max() {
  angle_max_ = 0;
}
inline ::google::protobuf::int32 LaserScan::angle_max() const {
  // @@protoc_insertion_point(field_get:LaserScan.angle_max)
  return angle_max_;
}
inline void LaserScan::set_angle_max(::google::protobuf::int32 value) {
  
  angle_max_ = value;
  // @@protoc_insertion_point(field_set:LaserScan.angle_max)
}

// optional int32 angle_increment = 3;
inline void LaserScan::clear_angle_increment() {
  angle_increment_ = 0;
}
inline ::google::protobuf::int32 LaserScan::angle_increment() const {
  // @@protoc_insertion_point(field_get:LaserScan.angle_increment)
  return angle_increment_;
}
inline void LaserScan::set_angle_increment(::google::protobuf::int32 value) {
  
  angle_increment_ = value;
  // @@protoc_insertion_point(field_set:LaserScan.angle_increment)
}

// optional int32 time_increment = 4;
inline void LaserScan::clear_time_increment() {
  time_increment_ = 0;
}
inline ::google::protobuf::int32 LaserScan::time_increment() const {
  // @@protoc_insertion_point(field_get:LaserScan.time_increment)
  return time_increment_;
}
inline void LaserScan::set_time_increment(::google::protobuf::int32 value) {
  
  time_increment_ = value;
  // @@protoc_insertion_point(field_set:LaserScan.time_increment)
}

// optional int32 scan_time = 5;
inline void LaserScan::clear_scan_time() {
  scan_time_ = 0;
}
inline ::google::protobuf::int32 LaserScan::scan_time() const {
  // @@protoc_insertion_point(field_get:LaserScan.scan_time)
  return scan_time_;
}
inline void LaserScan::set_scan_time(::google::protobuf::int32 value) {
  
  scan_time_ = value;
  // @@protoc_insertion_point(field_set:LaserScan.scan_time)
}

// optional int32 range_min = 6;
inline void LaserScan::clear_range_min() {
  range_min_ = 0;
}
inline ::google::protobuf::int32 LaserScan::range_min() const {
  // @@protoc_insertion_point(field_get:LaserScan.range_min)
  return range_min_;
}
inline void LaserScan::set_range_min(::google::protobuf::int32 value) {
  
  range_min_ = value;
  // @@protoc_insertion_point(field_set:LaserScan.range_min)
}

// optional int32 range_max = 7;
inline void LaserScan::clear_range_max() {
  range_max_ = 0;
}
inline ::google::protobuf::int32 LaserScan::range_max() const {
  // @@protoc_insertion_point(field_get:LaserScan.range_max)
  return range_max_;
}
inline void LaserScan::set_range_max(::google::protobuf::int32 value) {
  
  range_max_ = value;
  // @@protoc_insertion_point(field_set:LaserScan.range_max)
}

// repeated int32 ranges = 8;
inline int LaserScan::ranges_size() const {
  return ranges_.size();
}
inline void LaserScan::clear_ranges() {
  ranges_.Clear();
}
inline ::google::protobuf::int32 LaserScan::ranges(int index) const {
  // @@protoc_insertion_point(field_get:LaserScan.ranges)
  return ranges_.Get(index);
}
inline void LaserScan::set_ranges(int index, ::google::protobuf::int32 value) {
  ranges_.Set(index, value);
  // @@protoc_insertion_point(field_set:LaserScan.ranges)
}
inline void LaserScan::add_ranges(::google::protobuf::int32 value) {
  ranges_.Add(value);
  // @@protoc_insertion_point(field_add:LaserScan.ranges)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LaserScan::ranges() const {
  // @@protoc_insertion_point(field_list:LaserScan.ranges)
  return ranges_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LaserScan::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:LaserScan.ranges)
  return &ranges_;
}

// repeated int32 intensities = 9;
inline int LaserScan::intensities_size() const {
  return intensities_.size();
}
inline void LaserScan::clear_intensities() {
  intensities_.Clear();
}
inline ::google::protobuf::int32 LaserScan::intensities(int index) const {
  // @@protoc_insertion_point(field_get:LaserScan.intensities)
  return intensities_.Get(index);
}
inline void LaserScan::set_intensities(int index, ::google::protobuf::int32 value) {
  intensities_.Set(index, value);
  // @@protoc_insertion_point(field_set:LaserScan.intensities)
}
inline void LaserScan::add_intensities(::google::protobuf::int32 value) {
  intensities_.Add(value);
  // @@protoc_insertion_point(field_add:LaserScan.intensities)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LaserScan::intensities() const {
  // @@protoc_insertion_point(field_list:LaserScan.intensities)
  return intensities_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LaserScan::mutable_intensities() {
  // @@protoc_insertion_point(field_mutable_list:LaserScan.intensities)
  return &intensities_;
}

inline const LaserScan* LaserScan::internal_default_instance() {
  return &LaserScan_default_instance_.get();
}
// -------------------------------------------------------------------

// YXPoint3D

// optional int32 x = 1;
inline void YXPoint3D::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 YXPoint3D::x() const {
  // @@protoc_insertion_point(field_get:YXPoint3D.x)
  return x_;
}
inline void YXPoint3D::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:YXPoint3D.x)
}

// optional int32 y = 2;
inline void YXPoint3D::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 YXPoint3D::y() const {
  // @@protoc_insertion_point(field_get:YXPoint3D.y)
  return y_;
}
inline void YXPoint3D::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:YXPoint3D.y)
}

// optional int32 z = 3;
inline void YXPoint3D::clear_z() {
  z_ = 0;
}
inline ::google::protobuf::int32 YXPoint3D::z() const {
  // @@protoc_insertion_point(field_get:YXPoint3D.z)
  return z_;
}
inline void YXPoint3D::set_z(::google::protobuf::int32 value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:YXPoint3D.z)
}

inline const YXPoint3D* YXPoint3D::internal_default_instance() {
  return &YXPoint3D_default_instance_.get();
}
// -------------------------------------------------------------------

// PointCloud

// repeated .YXPoint3D points = 1;
inline int PointCloud::points_size() const {
  return points_.size();
}
inline void PointCloud::clear_points() {
  points_.Clear();
}
inline const ::YXPoint3D& PointCloud::points(int index) const {
  // @@protoc_insertion_point(field_get:PointCloud.points)
  return points_.Get(index);
}
inline ::YXPoint3D* PointCloud::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:PointCloud.points)
  return points_.Mutable(index);
}
inline ::YXPoint3D* PointCloud::add_points() {
  // @@protoc_insertion_point(field_add:PointCloud.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::YXPoint3D >*
PointCloud::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:PointCloud.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::YXPoint3D >&
PointCloud::points() const {
  // @@protoc_insertion_point(field_list:PointCloud.points)
  return points_;
}

inline const PointCloud* PointCloud::internal_default_instance() {
  return &PointCloud_default_instance_.get();
}
// -------------------------------------------------------------------

// Odometry_Pose_Position

// optional int32 x = 1;
inline void Odometry_Pose_Position::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 Odometry_Pose_Position::x() const {
  // @@protoc_insertion_point(field_get:Odometry.Pose.Position.x)
  return x_;
}
inline void Odometry_Pose_Position::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Odometry.Pose.Position.x)
}

// optional int32 y = 2;
inline void Odometry_Pose_Position::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 Odometry_Pose_Position::y() const {
  // @@protoc_insertion_point(field_get:Odometry.Pose.Position.y)
  return y_;
}
inline void Odometry_Pose_Position::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Odometry.Pose.Position.y)
}

// optional int32 z = 3;
inline void Odometry_Pose_Position::clear_z() {
  z_ = 0;
}
inline ::google::protobuf::int32 Odometry_Pose_Position::z() const {
  // @@protoc_insertion_point(field_get:Odometry.Pose.Position.z)
  return z_;
}
inline void Odometry_Pose_Position::set_z(::google::protobuf::int32 value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Odometry.Pose.Position.z)
}

inline const Odometry_Pose_Position* Odometry_Pose_Position::internal_default_instance() {
  return &Odometry_Pose_Position_default_instance_.get();
}
// -------------------------------------------------------------------

// Odometry_Pose_Orientation

// optional int32 x = 1;
inline void Odometry_Pose_Orientation::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 Odometry_Pose_Orientation::x() const {
  // @@protoc_insertion_point(field_get:Odometry.Pose.Orientation.x)
  return x_;
}
inline void Odometry_Pose_Orientation::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Odometry.Pose.Orientation.x)
}

// optional int32 y = 2;
inline void Odometry_Pose_Orientation::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 Odometry_Pose_Orientation::y() const {
  // @@protoc_insertion_point(field_get:Odometry.Pose.Orientation.y)
  return y_;
}
inline void Odometry_Pose_Orientation::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Odometry.Pose.Orientation.y)
}

// optional int32 z = 3;
inline void Odometry_Pose_Orientation::clear_z() {
  z_ = 0;
}
inline ::google::protobuf::int32 Odometry_Pose_Orientation::z() const {
  // @@protoc_insertion_point(field_get:Odometry.Pose.Orientation.z)
  return z_;
}
inline void Odometry_Pose_Orientation::set_z(::google::protobuf::int32 value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Odometry.Pose.Orientation.z)
}

// optional int32 w = 4;
inline void Odometry_Pose_Orientation::clear_w() {
  w_ = 0;
}
inline ::google::protobuf::int32 Odometry_Pose_Orientation::w() const {
  // @@protoc_insertion_point(field_get:Odometry.Pose.Orientation.w)
  return w_;
}
inline void Odometry_Pose_Orientation::set_w(::google::protobuf::int32 value) {
  
  w_ = value;
  // @@protoc_insertion_point(field_set:Odometry.Pose.Orientation.w)
}

inline const Odometry_Pose_Orientation* Odometry_Pose_Orientation::internal_default_instance() {
  return &Odometry_Pose_Orientation_default_instance_.get();
}
// -------------------------------------------------------------------

// Odometry_Pose

// optional .Odometry.Pose.Position position = 1;
inline bool Odometry_Pose::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void Odometry_Pose::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) delete position_;
  position_ = NULL;
}
inline const ::Odometry_Pose_Position& Odometry_Pose::position() const {
  // @@protoc_insertion_point(field_get:Odometry.Pose.position)
  return position_ != NULL ? *position_
                         : *::Odometry_Pose_Position::internal_default_instance();
}
inline ::Odometry_Pose_Position* Odometry_Pose::mutable_position() {
  
  if (position_ == NULL) {
    position_ = new ::Odometry_Pose_Position;
  }
  // @@protoc_insertion_point(field_mutable:Odometry.Pose.position)
  return position_;
}
inline ::Odometry_Pose_Position* Odometry_Pose::release_position() {
  // @@protoc_insertion_point(field_release:Odometry.Pose.position)
  
  ::Odometry_Pose_Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Odometry_Pose::set_allocated_position(::Odometry_Pose_Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Odometry.Pose.position)
}

// optional .Odometry.Pose.Orientation orientation = 2;
inline bool Odometry_Pose::has_orientation() const {
  return this != internal_default_instance() && orientation_ != NULL;
}
inline void Odometry_Pose::clear_orientation() {
  if (GetArenaNoVirtual() == NULL && orientation_ != NULL) delete orientation_;
  orientation_ = NULL;
}
inline const ::Odometry_Pose_Orientation& Odometry_Pose::orientation() const {
  // @@protoc_insertion_point(field_get:Odometry.Pose.orientation)
  return orientation_ != NULL ? *orientation_
                         : *::Odometry_Pose_Orientation::internal_default_instance();
}
inline ::Odometry_Pose_Orientation* Odometry_Pose::mutable_orientation() {
  
  if (orientation_ == NULL) {
    orientation_ = new ::Odometry_Pose_Orientation;
  }
  // @@protoc_insertion_point(field_mutable:Odometry.Pose.orientation)
  return orientation_;
}
inline ::Odometry_Pose_Orientation* Odometry_Pose::release_orientation() {
  // @@protoc_insertion_point(field_release:Odometry.Pose.orientation)
  
  ::Odometry_Pose_Orientation* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void Odometry_Pose::set_allocated_orientation(::Odometry_Pose_Orientation* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Odometry.Pose.orientation)
}

inline const Odometry_Pose* Odometry_Pose::internal_default_instance() {
  return &Odometry_Pose_default_instance_.get();
}
// -------------------------------------------------------------------

// Odometry_Twist_Linear

// optional int32 x = 1;
inline void Odometry_Twist_Linear::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 Odometry_Twist_Linear::x() const {
  // @@protoc_insertion_point(field_get:Odometry.Twist.Linear.x)
  return x_;
}
inline void Odometry_Twist_Linear::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Odometry.Twist.Linear.x)
}

// optional int32 y = 2;
inline void Odometry_Twist_Linear::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 Odometry_Twist_Linear::y() const {
  // @@protoc_insertion_point(field_get:Odometry.Twist.Linear.y)
  return y_;
}
inline void Odometry_Twist_Linear::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Odometry.Twist.Linear.y)
}

// optional int32 z = 3;
inline void Odometry_Twist_Linear::clear_z() {
  z_ = 0;
}
inline ::google::protobuf::int32 Odometry_Twist_Linear::z() const {
  // @@protoc_insertion_point(field_get:Odometry.Twist.Linear.z)
  return z_;
}
inline void Odometry_Twist_Linear::set_z(::google::protobuf::int32 value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Odometry.Twist.Linear.z)
}

inline const Odometry_Twist_Linear* Odometry_Twist_Linear::internal_default_instance() {
  return &Odometry_Twist_Linear_default_instance_.get();
}
// -------------------------------------------------------------------

// Odometry_Twist_Angular

// optional int32 x = 1;
inline void Odometry_Twist_Angular::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 Odometry_Twist_Angular::x() const {
  // @@protoc_insertion_point(field_get:Odometry.Twist.Angular.x)
  return x_;
}
inline void Odometry_Twist_Angular::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Odometry.Twist.Angular.x)
}

// optional int32 y = 2;
inline void Odometry_Twist_Angular::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 Odometry_Twist_Angular::y() const {
  // @@protoc_insertion_point(field_get:Odometry.Twist.Angular.y)
  return y_;
}
inline void Odometry_Twist_Angular::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Odometry.Twist.Angular.y)
}

// optional int32 z = 3;
inline void Odometry_Twist_Angular::clear_z() {
  z_ = 0;
}
inline ::google::protobuf::int32 Odometry_Twist_Angular::z() const {
  // @@protoc_insertion_point(field_get:Odometry.Twist.Angular.z)
  return z_;
}
inline void Odometry_Twist_Angular::set_z(::google::protobuf::int32 value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Odometry.Twist.Angular.z)
}

inline const Odometry_Twist_Angular* Odometry_Twist_Angular::internal_default_instance() {
  return &Odometry_Twist_Angular_default_instance_.get();
}
// -------------------------------------------------------------------

// Odometry_Twist

// optional .Odometry.Twist.Linear linear = 1;
inline bool Odometry_Twist::has_linear() const {
  return this != internal_default_instance() && linear_ != NULL;
}
inline void Odometry_Twist::clear_linear() {
  if (GetArenaNoVirtual() == NULL && linear_ != NULL) delete linear_;
  linear_ = NULL;
}
inline const ::Odometry_Twist_Linear& Odometry_Twist::linear() const {
  // @@protoc_insertion_point(field_get:Odometry.Twist.linear)
  return linear_ != NULL ? *linear_
                         : *::Odometry_Twist_Linear::internal_default_instance();
}
inline ::Odometry_Twist_Linear* Odometry_Twist::mutable_linear() {
  
  if (linear_ == NULL) {
    linear_ = new ::Odometry_Twist_Linear;
  }
  // @@protoc_insertion_point(field_mutable:Odometry.Twist.linear)
  return linear_;
}
inline ::Odometry_Twist_Linear* Odometry_Twist::release_linear() {
  // @@protoc_insertion_point(field_release:Odometry.Twist.linear)
  
  ::Odometry_Twist_Linear* temp = linear_;
  linear_ = NULL;
  return temp;
}
inline void Odometry_Twist::set_allocated_linear(::Odometry_Twist_Linear* linear) {
  delete linear_;
  linear_ = linear;
  if (linear) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Odometry.Twist.linear)
}

// optional .Odometry.Twist.Angular angular = 2;
inline bool Odometry_Twist::has_angular() const {
  return this != internal_default_instance() && angular_ != NULL;
}
inline void Odometry_Twist::clear_angular() {
  if (GetArenaNoVirtual() == NULL && angular_ != NULL) delete angular_;
  angular_ = NULL;
}
inline const ::Odometry_Twist_Angular& Odometry_Twist::angular() const {
  // @@protoc_insertion_point(field_get:Odometry.Twist.angular)
  return angular_ != NULL ? *angular_
                         : *::Odometry_Twist_Angular::internal_default_instance();
}
inline ::Odometry_Twist_Angular* Odometry_Twist::mutable_angular() {
  
  if (angular_ == NULL) {
    angular_ = new ::Odometry_Twist_Angular;
  }
  // @@protoc_insertion_point(field_mutable:Odometry.Twist.angular)
  return angular_;
}
inline ::Odometry_Twist_Angular* Odometry_Twist::release_angular() {
  // @@protoc_insertion_point(field_release:Odometry.Twist.angular)
  
  ::Odometry_Twist_Angular* temp = angular_;
  angular_ = NULL;
  return temp;
}
inline void Odometry_Twist::set_allocated_angular(::Odometry_Twist_Angular* angular) {
  delete angular_;
  angular_ = angular;
  if (angular) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Odometry.Twist.angular)
}

inline const Odometry_Twist* Odometry_Twist::internal_default_instance() {
  return &Odometry_Twist_default_instance_.get();
}
// -------------------------------------------------------------------

// Odometry

// optional .Odometry.Pose pose = 1;
inline bool Odometry::has_pose() const {
  return this != internal_default_instance() && pose_ != NULL;
}
inline void Odometry::clear_pose() {
  if (GetArenaNoVirtual() == NULL && pose_ != NULL) delete pose_;
  pose_ = NULL;
}
inline const ::Odometry_Pose& Odometry::pose() const {
  // @@protoc_insertion_point(field_get:Odometry.pose)
  return pose_ != NULL ? *pose_
                         : *::Odometry_Pose::internal_default_instance();
}
inline ::Odometry_Pose* Odometry::mutable_pose() {
  
  if (pose_ == NULL) {
    pose_ = new ::Odometry_Pose;
  }
  // @@protoc_insertion_point(field_mutable:Odometry.pose)
  return pose_;
}
inline ::Odometry_Pose* Odometry::release_pose() {
  // @@protoc_insertion_point(field_release:Odometry.pose)
  
  ::Odometry_Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void Odometry::set_allocated_pose(::Odometry_Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Odometry.pose)
}

// optional .Odometry.Twist twist = 2;
inline bool Odometry::has_twist() const {
  return this != internal_default_instance() && twist_ != NULL;
}
inline void Odometry::clear_twist() {
  if (GetArenaNoVirtual() == NULL && twist_ != NULL) delete twist_;
  twist_ = NULL;
}
inline const ::Odometry_Twist& Odometry::twist() const {
  // @@protoc_insertion_point(field_get:Odometry.twist)
  return twist_ != NULL ? *twist_
                         : *::Odometry_Twist::internal_default_instance();
}
inline ::Odometry_Twist* Odometry::mutable_twist() {
  
  if (twist_ == NULL) {
    twist_ = new ::Odometry_Twist;
  }
  // @@protoc_insertion_point(field_mutable:Odometry.twist)
  return twist_;
}
inline ::Odometry_Twist* Odometry::release_twist() {
  // @@protoc_insertion_point(field_release:Odometry.twist)
  
  ::Odometry_Twist* temp = twist_;
  twist_ = NULL;
  return temp;
}
inline void Odometry::set_allocated_twist(::Odometry_Twist* twist) {
  delete twist_;
  twist_ = twist;
  if (twist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Odometry.twist)
}

// optional int64 header_timestamp = 3;
inline void Odometry::clear_header_timestamp() {
  header_timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Odometry::header_timestamp() const {
  // @@protoc_insertion_point(field_get:Odometry.header_timestamp)
  return header_timestamp_;
}
inline void Odometry::set_header_timestamp(::google::protobuf::int64 value) {
  
  header_timestamp_ = value;
  // @@protoc_insertion_point(field_set:Odometry.header_timestamp)
}

inline const Odometry* Odometry::internal_default_instance() {
  return &Odometry_default_instance_.get();
}
// -------------------------------------------------------------------

// Imu_LinearAcceleration

// optional int32 x = 1;
inline void Imu_LinearAcceleration::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 Imu_LinearAcceleration::x() const {
  // @@protoc_insertion_point(field_get:Imu.LinearAcceleration.x)
  return x_;
}
inline void Imu_LinearAcceleration::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Imu.LinearAcceleration.x)
}

// optional int32 y = 2;
inline void Imu_LinearAcceleration::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 Imu_LinearAcceleration::y() const {
  // @@protoc_insertion_point(field_get:Imu.LinearAcceleration.y)
  return y_;
}
inline void Imu_LinearAcceleration::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Imu.LinearAcceleration.y)
}

// optional int32 z = 3;
inline void Imu_LinearAcceleration::clear_z() {
  z_ = 0;
}
inline ::google::protobuf::int32 Imu_LinearAcceleration::z() const {
  // @@protoc_insertion_point(field_get:Imu.LinearAcceleration.z)
  return z_;
}
inline void Imu_LinearAcceleration::set_z(::google::protobuf::int32 value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Imu.LinearAcceleration.z)
}

inline const Imu_LinearAcceleration* Imu_LinearAcceleration::internal_default_instance() {
  return &Imu_LinearAcceleration_default_instance_.get();
}
// -------------------------------------------------------------------

// Imu_AngularVelocity

// optional int32 x = 1;
inline void Imu_AngularVelocity::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 Imu_AngularVelocity::x() const {
  // @@protoc_insertion_point(field_get:Imu.AngularVelocity.x)
  return x_;
}
inline void Imu_AngularVelocity::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Imu.AngularVelocity.x)
}

// optional int32 y = 2;
inline void Imu_AngularVelocity::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 Imu_AngularVelocity::y() const {
  // @@protoc_insertion_point(field_get:Imu.AngularVelocity.y)
  return y_;
}
inline void Imu_AngularVelocity::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Imu.AngularVelocity.y)
}

// optional int32 z = 3;
inline void Imu_AngularVelocity::clear_z() {
  z_ = 0;
}
inline ::google::protobuf::int32 Imu_AngularVelocity::z() const {
  // @@protoc_insertion_point(field_get:Imu.AngularVelocity.z)
  return z_;
}
inline void Imu_AngularVelocity::set_z(::google::protobuf::int32 value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Imu.AngularVelocity.z)
}

inline const Imu_AngularVelocity* Imu_AngularVelocity::internal_default_instance() {
  return &Imu_AngularVelocity_default_instance_.get();
}
// -------------------------------------------------------------------

// Imu_Orientation

// optional int32 x = 1;
inline void Imu_Orientation::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 Imu_Orientation::x() const {
  // @@protoc_insertion_point(field_get:Imu.Orientation.x)
  return x_;
}
inline void Imu_Orientation::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Imu.Orientation.x)
}

// optional int32 y = 2;
inline void Imu_Orientation::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 Imu_Orientation::y() const {
  // @@protoc_insertion_point(field_get:Imu.Orientation.y)
  return y_;
}
inline void Imu_Orientation::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Imu.Orientation.y)
}

// optional int32 z = 3;
inline void Imu_Orientation::clear_z() {
  z_ = 0;
}
inline ::google::protobuf::int32 Imu_Orientation::z() const {
  // @@protoc_insertion_point(field_get:Imu.Orientation.z)
  return z_;
}
inline void Imu_Orientation::set_z(::google::protobuf::int32 value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Imu.Orientation.z)
}

// optional int32 w = 4;
inline void Imu_Orientation::clear_w() {
  w_ = 0;
}
inline ::google::protobuf::int32 Imu_Orientation::w() const {
  // @@protoc_insertion_point(field_get:Imu.Orientation.w)
  return w_;
}
inline void Imu_Orientation::set_w(::google::protobuf::int32 value) {
  
  w_ = value;
  // @@protoc_insertion_point(field_set:Imu.Orientation.w)
}

inline const Imu_Orientation* Imu_Orientation::internal_default_instance() {
  return &Imu_Orientation_default_instance_.get();
}
// -------------------------------------------------------------------

// Imu

// optional .Imu.LinearAcceleration linear_acceleration = 1;
inline bool Imu::has_linear_acceleration() const {
  return this != internal_default_instance() && linear_acceleration_ != NULL;
}
inline void Imu::clear_linear_acceleration() {
  if (GetArenaNoVirtual() == NULL && linear_acceleration_ != NULL) delete linear_acceleration_;
  linear_acceleration_ = NULL;
}
inline const ::Imu_LinearAcceleration& Imu::linear_acceleration() const {
  // @@protoc_insertion_point(field_get:Imu.linear_acceleration)
  return linear_acceleration_ != NULL ? *linear_acceleration_
                         : *::Imu_LinearAcceleration::internal_default_instance();
}
inline ::Imu_LinearAcceleration* Imu::mutable_linear_acceleration() {
  
  if (linear_acceleration_ == NULL) {
    linear_acceleration_ = new ::Imu_LinearAcceleration;
  }
  // @@protoc_insertion_point(field_mutable:Imu.linear_acceleration)
  return linear_acceleration_;
}
inline ::Imu_LinearAcceleration* Imu::release_linear_acceleration() {
  // @@protoc_insertion_point(field_release:Imu.linear_acceleration)
  
  ::Imu_LinearAcceleration* temp = linear_acceleration_;
  linear_acceleration_ = NULL;
  return temp;
}
inline void Imu::set_allocated_linear_acceleration(::Imu_LinearAcceleration* linear_acceleration) {
  delete linear_acceleration_;
  linear_acceleration_ = linear_acceleration;
  if (linear_acceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Imu.linear_acceleration)
}

// optional .Imu.AngularVelocity angular_velocity = 2;
inline bool Imu::has_angular_velocity() const {
  return this != internal_default_instance() && angular_velocity_ != NULL;
}
inline void Imu::clear_angular_velocity() {
  if (GetArenaNoVirtual() == NULL && angular_velocity_ != NULL) delete angular_velocity_;
  angular_velocity_ = NULL;
}
inline const ::Imu_AngularVelocity& Imu::angular_velocity() const {
  // @@protoc_insertion_point(field_get:Imu.angular_velocity)
  return angular_velocity_ != NULL ? *angular_velocity_
                         : *::Imu_AngularVelocity::internal_default_instance();
}
inline ::Imu_AngularVelocity* Imu::mutable_angular_velocity() {
  
  if (angular_velocity_ == NULL) {
    angular_velocity_ = new ::Imu_AngularVelocity;
  }
  // @@protoc_insertion_point(field_mutable:Imu.angular_velocity)
  return angular_velocity_;
}
inline ::Imu_AngularVelocity* Imu::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:Imu.angular_velocity)
  
  ::Imu_AngularVelocity* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline void Imu::set_allocated_angular_velocity(::Imu_AngularVelocity* angular_velocity) {
  delete angular_velocity_;
  angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Imu.angular_velocity)
}

// optional .Imu.Orientation orientation = 3;
inline bool Imu::has_orientation() const {
  return this != internal_default_instance() && orientation_ != NULL;
}
inline void Imu::clear_orientation() {
  if (GetArenaNoVirtual() == NULL && orientation_ != NULL) delete orientation_;
  orientation_ = NULL;
}
inline const ::Imu_Orientation& Imu::orientation() const {
  // @@protoc_insertion_point(field_get:Imu.orientation)
  return orientation_ != NULL ? *orientation_
                         : *::Imu_Orientation::internal_default_instance();
}
inline ::Imu_Orientation* Imu::mutable_orientation() {
  
  if (orientation_ == NULL) {
    orientation_ = new ::Imu_Orientation;
  }
  // @@protoc_insertion_point(field_mutable:Imu.orientation)
  return orientation_;
}
inline ::Imu_Orientation* Imu::release_orientation() {
  // @@protoc_insertion_point(field_release:Imu.orientation)
  
  ::Imu_Orientation* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void Imu::set_allocated_orientation(::Imu_Orientation* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Imu.orientation)
}

// optional int64 header_timestamp = 4;
inline void Imu::clear_header_timestamp() {
  header_timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Imu::header_timestamp() const {
  // @@protoc_insertion_point(field_get:Imu.header_timestamp)
  return header_timestamp_;
}
inline void Imu::set_header_timestamp(::google::protobuf::int64 value) {
  
  header_timestamp_ = value;
  // @@protoc_insertion_point(field_set:Imu.header_timestamp)
}

inline const Imu* Imu::internal_default_instance() {
  return &Imu_default_instance_.get();
}
// -------------------------------------------------------------------

// SensorData

// optional .PointCloud raw_laser_scan = 1;
inline bool SensorData::has_raw_laser_scan() const {
  return this != internal_default_instance() && raw_laser_scan_ != NULL;
}
inline void SensorData::clear_raw_laser_scan() {
  if (GetArenaNoVirtual() == NULL && raw_laser_scan_ != NULL) delete raw_laser_scan_;
  raw_laser_scan_ = NULL;
}
inline const ::PointCloud& SensorData::raw_laser_scan() const {
  // @@protoc_insertion_point(field_get:SensorData.raw_laser_scan)
  return raw_laser_scan_ != NULL ? *raw_laser_scan_
                         : *::PointCloud::internal_default_instance();
}
inline ::PointCloud* SensorData::mutable_raw_laser_scan() {
  
  if (raw_laser_scan_ == NULL) {
    raw_laser_scan_ = new ::PointCloud;
  }
  // @@protoc_insertion_point(field_mutable:SensorData.raw_laser_scan)
  return raw_laser_scan_;
}
inline ::PointCloud* SensorData::release_raw_laser_scan() {
  // @@protoc_insertion_point(field_release:SensorData.raw_laser_scan)
  
  ::PointCloud* temp = raw_laser_scan_;
  raw_laser_scan_ = NULL;
  return temp;
}
inline void SensorData::set_allocated_raw_laser_scan(::PointCloud* raw_laser_scan) {
  delete raw_laser_scan_;
  raw_laser_scan_ = raw_laser_scan;
  if (raw_laser_scan) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:SensorData.raw_laser_scan)
}

// optional .PointCloud laser_scan_360 = 2;
inline bool SensorData::has_laser_scan_360() const {
  return this != internal_default_instance() && laser_scan_360_ != NULL;
}
inline void SensorData::clear_laser_scan_360() {
  if (GetArenaNoVirtual() == NULL && laser_scan_360_ != NULL) delete laser_scan_360_;
  laser_scan_360_ = NULL;
}
inline const ::PointCloud& SensorData::laser_scan_360() const {
  // @@protoc_insertion_point(field_get:SensorData.laser_scan_360)
  return laser_scan_360_ != NULL ? *laser_scan_360_
                         : *::PointCloud::internal_default_instance();
}
inline ::PointCloud* SensorData::mutable_laser_scan_360() {
  
  if (laser_scan_360_ == NULL) {
    laser_scan_360_ = new ::PointCloud;
  }
  // @@protoc_insertion_point(field_mutable:SensorData.laser_scan_360)
  return laser_scan_360_;
}
inline ::PointCloud* SensorData::release_laser_scan_360() {
  // @@protoc_insertion_point(field_release:SensorData.laser_scan_360)
  
  ::PointCloud* temp = laser_scan_360_;
  laser_scan_360_ = NULL;
  return temp;
}
inline void SensorData::set_allocated_laser_scan_360(::PointCloud* laser_scan_360) {
  delete laser_scan_360_;
  laser_scan_360_ = laser_scan_360;
  if (laser_scan_360) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:SensorData.laser_scan_360)
}

// optional .PointCloud raw_point_cloud = 3;
inline bool SensorData::has_raw_point_cloud() const {
  return this != internal_default_instance() && raw_point_cloud_ != NULL;
}
inline void SensorData::clear_raw_point_cloud() {
  if (GetArenaNoVirtual() == NULL && raw_point_cloud_ != NULL) delete raw_point_cloud_;
  raw_point_cloud_ = NULL;
}
inline const ::PointCloud& SensorData::raw_point_cloud() const {
  // @@protoc_insertion_point(field_get:SensorData.raw_point_cloud)
  return raw_point_cloud_ != NULL ? *raw_point_cloud_
                         : *::PointCloud::internal_default_instance();
}
inline ::PointCloud* SensorData::mutable_raw_point_cloud() {
  
  if (raw_point_cloud_ == NULL) {
    raw_point_cloud_ = new ::PointCloud;
  }
  // @@protoc_insertion_point(field_mutable:SensorData.raw_point_cloud)
  return raw_point_cloud_;
}
inline ::PointCloud* SensorData::release_raw_point_cloud() {
  // @@protoc_insertion_point(field_release:SensorData.raw_point_cloud)
  
  ::PointCloud* temp = raw_point_cloud_;
  raw_point_cloud_ = NULL;
  return temp;
}
inline void SensorData::set_allocated_raw_point_cloud(::PointCloud* raw_point_cloud) {
  delete raw_point_cloud_;
  raw_point_cloud_ = raw_point_cloud;
  if (raw_point_cloud) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:SensorData.raw_point_cloud)
}

// optional .PointCloud obs_point_cloud = 4;
inline bool SensorData::has_obs_point_cloud() const {
  return this != internal_default_instance() && obs_point_cloud_ != NULL;
}
inline void SensorData::clear_obs_point_cloud() {
  if (GetArenaNoVirtual() == NULL && obs_point_cloud_ != NULL) delete obs_point_cloud_;
  obs_point_cloud_ = NULL;
}
inline const ::PointCloud& SensorData::obs_point_cloud() const {
  // @@protoc_insertion_point(field_get:SensorData.obs_point_cloud)
  return obs_point_cloud_ != NULL ? *obs_point_cloud_
                         : *::PointCloud::internal_default_instance();
}
inline ::PointCloud* SensorData::mutable_obs_point_cloud() {
  
  if (obs_point_cloud_ == NULL) {
    obs_point_cloud_ = new ::PointCloud;
  }
  // @@protoc_insertion_point(field_mutable:SensorData.obs_point_cloud)
  return obs_point_cloud_;
}
inline ::PointCloud* SensorData::release_obs_point_cloud() {
  // @@protoc_insertion_point(field_release:SensorData.obs_point_cloud)
  
  ::PointCloud* temp = obs_point_cloud_;
  obs_point_cloud_ = NULL;
  return temp;
}
inline void SensorData::set_allocated_obs_point_cloud(::PointCloud* obs_point_cloud) {
  delete obs_point_cloud_;
  obs_point_cloud_ = obs_point_cloud;
  if (obs_point_cloud) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:SensorData.obs_point_cloud)
}

// optional .Odometry odometry = 5;
inline bool SensorData::has_odometry() const {
  return this != internal_default_instance() && odometry_ != NULL;
}
inline void SensorData::clear_odometry() {
  if (GetArenaNoVirtual() == NULL && odometry_ != NULL) delete odometry_;
  odometry_ = NULL;
}
inline const ::Odometry& SensorData::odometry() const {
  // @@protoc_insertion_point(field_get:SensorData.odometry)
  return odometry_ != NULL ? *odometry_
                         : *::Odometry::internal_default_instance();
}
inline ::Odometry* SensorData::mutable_odometry() {
  
  if (odometry_ == NULL) {
    odometry_ = new ::Odometry;
  }
  // @@protoc_insertion_point(field_mutable:SensorData.odometry)
  return odometry_;
}
inline ::Odometry* SensorData::release_odometry() {
  // @@protoc_insertion_point(field_release:SensorData.odometry)
  
  ::Odometry* temp = odometry_;
  odometry_ = NULL;
  return temp;
}
inline void SensorData::set_allocated_odometry(::Odometry* odometry) {
  delete odometry_;
  odometry_ = odometry;
  if (odometry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:SensorData.odometry)
}

// optional int64 secs = 6;
inline void SensorData::clear_secs() {
  secs_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SensorData::secs() const {
  // @@protoc_insertion_point(field_get:SensorData.secs)
  return secs_;
}
inline void SensorData::set_secs(::google::protobuf::int64 value) {
  
  secs_ = value;
  // @@protoc_insertion_point(field_set:SensorData.secs)
}

// optional int64 nsecs = 7;
inline void SensorData::clear_nsecs() {
  nsecs_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SensorData::nsecs() const {
  // @@protoc_insertion_point(field_get:SensorData.nsecs)
  return nsecs_;
}
inline void SensorData::set_nsecs(::google::protobuf::int64 value) {
  
  nsecs_ = value;
  // @@protoc_insertion_point(field_set:SensorData.nsecs)
}

inline const SensorData* SensorData::internal_default_instance() {
  return &SensorData_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_sensor_5fdata_2eproto__INCLUDED
